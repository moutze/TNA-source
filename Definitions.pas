{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ unit Definitions
  * Class for the definitions of units *
  Description:
  This class is the container of all TAH definitions. It includes the methods
  for the reading of the exported database file of definitions or any external
  source files. It also includes different retrieval methods.</P>
  Definitions are attached to the units of the terminology (not to the
  entities). From the unit definition, this class provides autogenerated
  taxonomic definitions for all entities of the unit.</P>
  The definitions in a file are necessarily compatible with the predefined
  record type for definitions. The provided reading method accepts a text
  file of fields separated by a delimiter character (see CurSep).</P>
  A definition is always of a predefined type. This type governs the way the
  definition text is managed, depending on the language of the definition.</P>
  This class accepts a predefined number of source files (see MaxSet constant).
  They must be loaded before any usage of their contained definitions. They are
  the unique way to feed this class. No modifying methods are available.</P>
  The definitions are grouped in a number of sets, each being originated in a
  dedicated source file and having a specific language governing its treatment.
  The position of a set is depending on the load sequence. A set can be
  identified by its filename.</P>
  Different sets may contain definitions for different units or for the same
  unit. The user of the class is responsible to check any set for the
  existence of the relevant definitions. This strategy allows the load of
  different versions of the same units, making possible direct comparisons.</P>
  A filter by Unit identifier is available: it applies to a single set and
  retrieves a list of all definitions related to the specified unit. The
  number N of filtered definitions defines the available positions that act as
  pointer to the definition records (from 1 to N). Further treatments are
  uniquely performed on the basis of these positions.</P>
  The generation of taxonomic definitions, based on the genus and differentia
  of the existing taxonomy, is available through specific methods. The
  language dependant treatment of definitions is actually provided for
  English and French.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
unit Definitions;

interface

uses
  TAHParam;

const
                             // Maximum number of sets (source files)
  MaxSet                     = 5;

type
  RangeSet                   = 1 .. MaxSet;
  tDefinition                = class( TObject )
  private
                             // All texts of definitions
    fDefin:                  array of DefRec;
                             // Filename for sets of definitions
    fFileName:               array[ RangeSet ] of String;
                             // Start position of sets (zero for empty set)
    fStart:                  array[ RangeSet ] of Integer;
                             // Stop position of sets
    fStop:                   array[ RangeSet ] of Integer;
                             // Language of sets
    fLang:                   array[ RangeSet ] of tLanguage;
                             // Selection list by UID
    fSelPos:                 array of Integer;
                             // Number of definitions in a set
    function                 GetTotDef(
                               Indx: RangeSet )
                               : Integer;
                             // Number of sets
    function                 GetNbSet()
                               : Integer;
                             // Filename of a set
    function                 GetFileName(
                               Indx: RangeSet )
                               : String;
                             // Retrieve the language of a set
    function                 GetLanguage(
                               Indx: RangeSet )
                               : TLanguage;
                             // Existing set
    function                 GetSet(
                               Indx: RangeSet )
                               : Boolean;
                             // Retrieve a position
    function                 GetSelPos(
                               Indx: RangeSet )
                               : Integer;
                             // Prepare an English taxonomic definition
    function                 MakeTaxENDefinition(
                               Indx: Integer;
                               Refer: Boolean;
                               IsNo: Boolean )
                               : String;
                             // Prepare a French taxonomic definition
    function                 MakeTaxFRDefinition(
                               Indx: Integer;
                               Refer: Boolean;
                               IsNo: Boolean )
                               : String;
                             // Prepare a Spanish taxonomic definition
    function                 MakeTaxESDefinition(
                               Indx: Integer;
                               Refer: Boolean;
                               IsNo: Boolean )
                               : String;
                             // Prepare a Russian taxonomic definition
    function                 MakeTaxRUDefinition(
                               Indx: Integer;
                               Refer: Boolean;
                               IsNo: Boolean )
                               : String;
                             // Prepare an English auto lateral definition
    function                 MakeAutoLateralENDef(
                               Indx: Integer;
                               Side: TLink )
                               : String;
                             // Prepare a French auto lateral definition
    function                 MakeAutoLateralFRDef(
                               Indx: Integer;
                               Side: TLink )
                               : String;
                             // Prepare a Spanish auto lateral definition
    function                 MakeAutoLateralESDef(
                               Indx: Integer;
                               Side: TLink )
                               : String;
                             // Prepare a Russian auto lateral definition
    function                 MakeAutoLateralRUDef(
                               Indx: Integer;
                               Side: TLink )
                               : String;
                             // Prepare an English auto pair definition
    function                 MakeAutoPairENDef(
                               Indx: Integer )
                               : String;
                             // Prepare a French auto pair definition
    function                 MakeAutoPairFRDef(
                               Indx: Integer )
                               : String;
                             // Prepare a Spanish auto pair definition
    function                 MakeAutoPairESDef(
                               Indx: Integer )
                               : String;
                             // Prepare a Russian auto pair definition
    function                 MakeAutoPairRUDef(
                               Indx: Integer )
                               : String;
                             // Prepare an English auto set definition
    function                 MakeAutoSetENDef(
                               Indx: Integer )
                               : String;
                             // Prepare a French auto set definition
    function                 MakeAutoSetFRDef(
                               Indx: Integer )
                               : String;
                             // Prepare an English auto pair set definition
    function                 MakeAutoPstENDef(
                               Indx: Integer )
                               : String;
                             // Prepare a French auto pair set definition
    function                 MakeAutoPstFRDef(
                               Indx: Integer )
                               : String;
                             // Prepare a Spanish auto pair set definition
    function                 MakeAutoPstESDef(
                               Indx: Integer )
                               : String;
                             // Prepare a Russian auto pair set definition
    function                 MakeAutoPstRUDef(
                               Indx: Integer )
                               : String;
  public
                             // Get number of definitions by set
    property                 TotDef[ Indx: RangeSet ]
                               : Integer read GetTotDef;
                             // Get filename by set
    property                 FileName[ Indx: RangeSet ]
                               : String read GetFileName;
                             // Get language by set
    property                 Language[ Indx: RangeSet ]
                               : tLanguage read GetLanguage;
                             // Get number of loaded sets
    property                 NbSet
                               : Integer read GetNbSet;
                             // Flag for existence of set
    property                 IsSet[ Indx: RangeSet ]
                               : Boolean read GetSet;
                             //
    property                 SelPos[ Indx: RangeSet ]
                               : Integer read GetSelPos;
                             // Read a definition source file
    procedure                ReadDefSourceFile(
                               Language: tLanguage;
                               FileName: String );
                             // Retrieve all definitions for a UID
    function                 FilterByUID(
                               UID: Integer;
                               OrdSet: RangeSet )
                               : Integer;
                             // Get a single definition record
    function                 Defin(
                               Index: Integer )
                               : DefRec;
                             // Retrieve a definition from filtered list
    function                 GetDefinition(
                               Position: Integer )
                               : DefRec;
                             // Retrieve the type of a definition
    function                 GetDefinitionType(
                               Position: Integer )
                               : TDefType;
                             // Prepare a taxonomic definition
    function                 MakeTaxDefinition(
                               Position: Integer;
                               Refer: Boolean = False;
                               IsNo: Boolean = False )
                               : String;
                             // Prepare an auto lateral taxonomic definition
    function                 MakeAutoLateralDef(
                               Position: Integer;
                               Side: TLink )
                               : String;
                             // Prepare an auto pair taxonomic definition
    function                 MakeAutoPairDef(
                               Position: Integer )
                               : String;
                             // Prepare an auto taxonomic set definition
    function                 MakeAutoSetDef(
                               Position: Integer )
                               : String;
                             // Prepare an auto taxonomic pair set definition
    function                 MakeAutoPstDef(
                               Position: Integer )
                               : String;
  end;




  // Resolve hyperlinks
    function                 MakeHyperlinks(
                               Mydef: String;
                               Lang: tLanguage = lt_English;
                               Refer: Boolean = False;
                               IsNo: Boolean = False )
                               : String;


implementation

uses
  TAHBrowser, SysUtils, FRProc, ENProc, ESProc, RUProc, Entity, Term,
  Classes;

function           tDefinition.GetTotDef(
  Indx:            RangeSet )
  :                Integer;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetTotDef
  * Get the number of definitions available in a set *
  Description:
  The method retrieves the number of available definitions in the specified set
  as exported from the TAH database or an external source file.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
begin
  if ( Self.FStart[ Indx ] > 0 ) then
    Result := Self.FStop[ Indx ] - Self.FStart[ Indx ] + 1
  else
    Result := 0;
end; // _______________________________________________________________GetTotDef

function           tDefinition.GetNbSet()
  :                Integer;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetNbSet
  * Get the number of sets *
  Description:
  The method retrieves the number of sets as exported from the TAH database
  or an external source file.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
var
  Indx:            Integer;
begin
  Result := 0;
  for Indx := 1 to MaxSet do
  begin
    if ( Self.FStart[ Indx ] = 0 ) then
      Break;
    Result := Indx;
  end; // for
end; // ________________________________________________________________GetNbSet

function           tDefinition.GetFileName(
  Indx:            RangeSet )
  :                String;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetFileName
  * Get the filename from the source file of a set *
  Description:
  The method retrieves the filename from which the specified set has been
  loaded.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
begin
  if ( Self.fStart[ Indx ] > 0 ) then
    Result := Self.fFileName[ Indx ]
  else
    Result := cEmpty;
end; // _____________________________________________________________GetFileName

function           tDefinition.GetLanguage(
  Indx:            RangeSet )
  :                tLanguage;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetLanguage
  * Get the language of a set specifying its treatment *
  Description:
  The method retrieves the language applicable to a set.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
begin
  if ( Self.FStart[ Indx ] > 0 ) then
    Result := Self.FLang[ Indx ]
  else
    Result := lt_None;
end; // _____________________________________________________________GetLanguage

function           TDefinition.GetSet(
  Indx:            RangeSet )
  :                Boolean;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetSet
  * Check for the existence of a set *
  Description:
  The method retrieves the start position of a set: a value greater
  than zero defines an existing set.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
begin
  if ( Self.FStart[ Indx ] > 0 ) then
    Result := True
  else
    Result := False;
end; // __________________________________________________________________GetSet

function           TDefinition.GetSelPos(
  Indx:            RangeSet )
  :                Integer;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetSelPos
  * Retrieve a position of definition *
  Description:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
begin
  Result := Self.FSelPos[ Indx ];
end; // _______________________________________________________________GetSelPos

procedure          tDefinition.ReadDefSourceFile(
  Language:        tLanguage;
  FileName:        String );
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ReadDefSourceFile
  * Read the definition records from database source file or external file *
  Description:
  This method reads any number of definition records available from the TAH
  database in the specified language. The filename and the language of the
  definitions are stored.</P>
  The source file is defined as UTF-8 and is read as a string list.</P>
  This method load the file content in a set. On multiple call to this method
  multiple sets may be created (up the maximum allowed value).</P>
  Each record of a definition is of the defined type (see DEFRec). The fields
  are pipe delimited by a special character (see CurSep). Each line of the
  source file contains one record. When processing a line, the fields are
  separated and stored in the specific variables of the record.</P>
  The start and stop positions of the actual set are stored and delimit the
  set. Its size, its language and its filename are available as properties.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
var
  Indz:            Integer;
  Indx:            RangeSet;
  Indy:            TDefType;
  IOR:             Integer;
  AllocRec:        Integer;
  Posit:           Integer;
  TotDef:          Integer;
  Count:           Integer;
  OrdSet:          RangeSet;
  FreeSet:         Boolean;
  Line:            String;
  Field:           String;
  MyDefRec:        DEFRec;
  MyType:          tDefType;
  MyStringList:    TStringList;
begin

  // Search for the next free set
  FreeSet := False;
  OrdSet := 1;
  for Indx := 1 to MaxSet do
  begin
    if ( Self.FStart[ Indx ] = 0 ) then
    begin
      OrdSet := Indx;
      FreeSet := True;
      Break;
    end;
  end; // for

  // Exit if all sets are already filled
  if ( not FreeSet ) then
    Exit;

  // Initialize the position for the new set
  if ( OrdSet = 1 ) then
    TotDef := 0
  else
    TotDef := Self.fStop[ OrdSet - 1 ];
    AllocRec := TotDef;
    Self.fStart[ OrdSet ] := TotDef + 1;

    // Read the entire file with adequate encoding
    MyStringList := TStringList.Create;
    MyStringList.LoadFromFile( FileName, TEncoding.UTF8 );

    // Loop on all lines of input file
    Count := MyStringList.Count;
    for Indz := 0 to Count - 1 do
    begin
      Line := MyStringList[ Indz ];

      // Allocate dynamic memory
      if ( TotDef >= AllocRec ) then
      begin
        Inc( AllocRec, 20 );
        SetLength( fDefin, AllocRec );
      end;

      // Loop on all fields of the record
      // Expected format is made of 5 fields:
      // TID¦Typ¦Src¦Dat¦Def
      Posit := Pos( CurSep, Line );
      MyDEFRec.UID := StrToInt( Copy( Line, 1, Posit - 1 ) );
      Line := Copy( Line, Posit + 1, Length( Line ) );
      Posit := Pos( CurSep, Line );
      Field := Copy( Line, 1, Posit - 1 );
      MyType := Low( tDefType );
      for Indy := Succ( Low( tDefType ) ) to High( tDefType ) do
      begin
        if ( Field = cDef[ Indy ] ) then
        begin
          MyType := Indy;
          Break;
        end;
      end; // for on all types
      MyDEFRec.Typ := MyType;
      Line := Copy( Line, Posit + 1, Length( Line ) );
      Posit := Pos( CurSep, Line );
      MyDEFRec.Src := Copy( Line, 1, Posit - 1 );
      Line := Copy( Line, Posit + 1, Length( Line ) );
      Posit := Pos( CurSep, Line );
      MyDEFRec.Dat := Copy( Line, 1, Posit - 1 );
      MyDEFRec.Def := Copy( Line, Posit + 1, Length( Line ) );

      // Store the new record
      fDefin[ TotDef ] := MyDefRec;
      Inc( TotDef );
    end; // for on all lines

    // Close the reading of source file
    Self.fFileName[ OrdSet ] := FileName;
    Self.fLang[ OrdSet ] := Language;
    Self.fStop[ OrdSet ] := TotDef;
    SetLength( fDefin, TotDef );
end; // _______________________________________________________ReadDefSourceFile

function           TDefinition.FilterByUID(
  UID:             Integer;
  OrdSet:          RangeSet )
  :                Integer;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ FilterByUID
  * Filter of all definitions for a specified UID and a specified set *
  Description:
  This method retrieves the number of available definition records attached
  to an unit specified by its UID. The positions of the retrieved definitions
  are stored internally.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
var
  Indx:            Integer;
  Indy:            Integer;
  MyUID:           Integer;
  TotDef:          Integer;
  NbFiltered:      Integer;
begin
  // Skip an empty set
  Result := 0;
  if ( Self.FStart[ OrdSet ] = 0 ) then
    Exit;

  // Loop on all definitions
  NbFiltered := 0;
  SetLength( Self.FSelPos, 20 );
  TotDef := Self.GetTotDef( OrdSet );
  for Indx := 0 to TotDef - 1 do
  begin
    Indy := Self.FStart[ OrdSet ] - 1 + Indx;
    MyUID := Self.FDefin[ Indy ].UID;
    if ( MyUID < UID ) then
      Continue;
    if ( MyUID > UID ) then
      Break;
    if ( MyUID = UID ) then
    begin
      Self.FSelPos[ NbFiltered ] := Indy;
      Inc( NbFiltered );
    end;
  end; // for on all definitions in a set
  SetLength( Self.FSelPos, NbFiltered );
  Result := NbFiltered;
end; // _____________________________________________________________FilterByUID

function           TDefinition.Defin(
  Index:           Integer )
  :                DefRec;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defin
  * Get a single definition *
  Description:
  This method retrieves a definition record from its position independantly
  of its proprietary set.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
begin
  if ( ( Index >= 0 ) and ( Index < Length( Self.FDefin ) ) ) then
    Result := Self.FDefin[ Index ];
end; // ___________________________________________________________________Defin

function           TDefinition.GetDefinition(
  Position:        Integer )
  :                DefRec;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetDefinition
  * Get a single definition from a filtered list *
  Description:
  This method retrieves a definition record from its filter position.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
var
  Indx:            Integer;
begin
  if ( ( Position >= 0 ) and ( Position < Length( Self.FSelPos ) ) ) then
  begin
    Indx := Self.FSelPos[ Position ];
    Result := Self.FDefin[ Indx ];
  end;
end; // ___________________________________________________________GetDefinition

function           TDefinition.GetDefinitionType(
  Position:        Integer )
  :                TDefType;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetDefinitionType
  * Get the type of a definition *
  Description:
  This method retrieves the type of a definition specified by its
  filtered position.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
var
  Indx:            Integer;
begin
  if ( ( Position >= 0 ) and ( Position < Length( Self.FSelPos ) ) ) then
  begin
    Indx := Self.FSelPos[ Position ];
    Result := Self.FDefin[ Indx ].Typ;
  end;
end; // _______________________________________________________GetDefinitionType

function           tDefinition.MakeTaxDefinition(
  Position:        Integer;
  Refer:           Boolean;
  IsNo:            Boolean )
  :                String;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MakeTaxDefinition
  * Prepare a taxonomic definition with genus and differentia *
  Description:
  This method prepares a taxonomic definition from its genus and the given
  differentia, as a full text ready to display in any language.</P>
  In case of a non existing entity or an entity without a specified taxonomic
  ancestor, the result is the empty string.</P>
  The taxonomic definition is built according to the rules of the language.
  The language of the definition is retrieved in order to call the relevant
  language dependant methods.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
var
  Indx:            Integer;
  Indy:            Integer;
  DefLg:           tLanguage;
begin
  // Define the entity
  Result := cEmpty;
  if ( ( Position >= 0 ) and ( Position < Length( Self.FSelPos ) ) ) then
    Indx := Self.FSelPos[ Position ]
  else
    Exit;

  // Search for the language of the definition
  DefLg := lt_None;
  for Indy := 1 to Self.NbSet do
  begin
    if ( ( Indx + 1 >= Self.FStart[ Indy ] ) and
         ( Indx < Self.FStop[ Indy ] ) ) then
      DefLg := Self.FLang[ Indy ];
  end;

  // Dispatch to the language specific methods
  if ( DefLg = lt_English ) then
     Result := Self.MakeTaxENDefinition( Indx, Refer, IsNo )
  else
  if ( DefLg = lt_French ) then
     Result := Self.MakeTaxFRDefinition( Indx, Refer, IsNo )
  else
  if ( DefLg = lt_Spanish ) then
     Result := Self.MakeTaxESDefinition( Indx, Refer, IsNo )
  else
  if ( DefLg = lt_Russian ) then
     Result := Self.MakeTaxRUDefinition( Indx, Refer, IsNo );
end; // _______________________________________________________MakeTaxDefinition

function           tDefinition.MakeTaxENDefinition(
  Indx:            Integer;
  Refer:           Boolean;
  IsNo:            Boolean )
  :                String;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MakeTaxENDefinition
  * Prepare a taxonomic definition with genus and differentia in English *
  Description:
  This method prepares a taxonomic definition from its genus and the given
  differentia, as a full English text ready to display. Resolution of
  references in hyperlinks to other units or entities is performed.</P>
  In case of a non existing entity or an entity without a specified taxonomic
  ancestor, the result is the empty string.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
var
  NbPos:           Integer;
  MyUID:           Integer;
  ActualGen:       Boolean;
  TaxDef:          String;
  Genus:           String;
  Differentia:     String;
  ArtForm:         String;
  Actual:          tEntity;
  Ancestor:        tEntity;
  MyPos:           Array[ 0 .. 2 ] of Integer;
begin
  // Define the entity
  MyUID := Self.FDefin[ Indx ].UID;
  Actual := TAH.GetUnitGenerator( MyUID );
  TaxDef := cEmpty;
  if ( Actual <> nil ) then
  begin

    // Search for genus name, the direct ancestor in taxonomy
    Ancestor := TAH.GetEntityByTID( Actual.TaxAnc );
    Genus := cEmpty;
    if ( Ancestor <> nil ) then
    begin

      // Search if the defined entity is generic
      NbPos := 0;
      ActualGen := False;
      TAH.GetPositionsByGen( Actual.TID, NbPos, MyPos );
      if ( Actual.TaxAnc > 0 ) then
        ActualGen := ( Length( Actual.TaxCh ) > 0 ) or ( NbPos > 0 );
      ActualGen := ActualGen or Actual.Generic;

      // Prepare the actual entity
      TaxDef := Actual.GetLibelle( lb_Official, lt_English );
      if ( ActualGen ) then
      begin
        ArtForm := 'A' + cSpace;
        if ( ( TaxDef <> cEmpty ) and
             ( CharInSet( TaxDef[ 1 ], [ 'a', 'e', 'i', 'o', 'u' ] ) ) ) then
          ArtForm := 'An' + cSpace;
      end else
      begin
        ArtForm := 'The' + cSpace;
      end;
      if ( not IsNo ) then
        TaxDef := BTAG + TaxDef + BETAG;
      TaxDef := ArtForm + TaxDef + cSpace;

      // Prepare the genus entity (exclude the top entity)
      if ( MyUID <> 10123 ) then
      begin
        Genus := Ancestor.GetLibelle( lb_Base, lt_English );
        Genus := cCul + Genus + cComma + cSpace + IntToStr( Ancestor.TID ) +
                 cCur;
        Genus := MakeHyperlinks( Genus, lt_English, Refer, IsNo );
        ArtForm := 'a';
        if CharInSet( Genus[ 1 ], [ 'a', 'e', 'i', 'o', 'u' ] ) then
          ArtForm := 'an';
        TaxDef := TaxDef + cSpace + 'is' + cSpace + ArtForm + cSpace + Genus;
        TaxDef := TaxDef + cSpace + 'which';
      end;

      // Prepare hyperlinks to other entities in the differentia
      Differentia := Self.FDefin[ Indx ].Def;
      Differentia := MakeHyperlinks( Differentia, lt_English, Refer, IsNo );

      // Add the differentia
      TaxDef := TaxDef + cSpace + Differentia;

      // Prepare the mention of the source
      if ( Self.FDefin[ Indx ].Src = 'FMA' ) then
        TaxDef := TaxDef + cSpace + '(Foundational Model of Anatomy)';
    end;
  end;
  Result := TaxDef;
end; // _____________________________________________________MakeTaxENDefinition

function           TDefinition.MakeTaxFRDefinition(
  Indx:            Integer;
  Refer:           Boolean;
  IsNo:            Boolean )
  :                String;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MakeTaxFRDefinition
  * Prepare a taxonomic definition with genus and differentia in French *
  Description:
  This method prepares a taxonomic definition from its genus and the given
  differentia, as a full French text ready to display. Resolution of
  references in hyperlinks to other units or entities is performed.</P>
  In case of a non existing entity or an entity without a specified taxonomic
  ancestor, the result is the empty string.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
var
  NbPos:           Integer;
  Ident:           Integer;
  IsRule:          Boolean;
  ActualGen:       Boolean;
  Basis:           String;
  First:           String;
  TaxDef:          String;
  Genus:           String;
  Diff:            String;
  Undef:           String;
  ArtForm:         String;
  Differentia:     String;
  Actual:          tEntity;
  Ancestor:        tEntity;
  Gender:          tGender;
  MyPos:           Array[ 0 .. 2 ] of Integer;
  MyTerm:          tFRTerm;
begin
  // Define the entity
  Actual := TAH.GetUnitGenerator( Self.FDefin[ Indx ].UID );
  TaxDef := cEmpty;
  if ( Actual <> nil ) then
  begin

    // Search for genus name, the direct ancestor in taxonomy
    Ancestor := TAH.GetEntityByTID( Actual.TaxAnc );
    Genus := cEmpty;
    Undef := cEmpty;
    if ( Ancestor <> nil ) then
    begin

      // Search if the defined entity is generic
      NbPos := 0;
      ActualGen := False;
      TAH.GetPositionsByGen( Actual.TID, NbPos, MyPos );
      if ( Actual.TaxAnc > 0 ) then
        ActualGen := ( Length( Actual.TaxCh ) > 0 ) or ( NbPos > 0 );
      ActualGen := ActualGen or Actual.Generic;

      // Find the basis
      First := Actual.GetLibelle( lb_Universal, lt_French, st_for );
      // First := Actual.GetLibelle( lb_Base, lt_French );
      MyTerm := tFRTerm.Create( First );
      Gender := MyTerm.GenderFR( IsRule, Ident );
      Basis := BTAG + First + BETAG;
      if ( ActualGen ) then
      begin
        ArtForm := 'Un' + cSpace;
        if ( Gender = ge_feminine ) then
          ArtForm := 'Une' + cSpace;
      end else
      begin
        if CharInSet( First[ 1 ], [ 'a', 'e', 'i', 'o', 'u' ] ) then
        begin
          ArtForm := 'L''';
        end else
        begin
          if ( Gender = ge_masculine ) then
          begin
            ArtForm := 'Le' + cSpace
          end else
          begin
            ArtForm := 'La' + cSpace;
          end;
        end;
      end;
      Basis := ArtForm + Basis + cSpace + 'est';

      // Find the genus
      Genus := Ancestor.GetLibelle( lb_Base, lt_French );
      MyTerm := TFRTerm.Create( Genus );
      Gender := MyTerm.GenderFR( IsRule, Ident );
      Genus := cCul + Genus + cComma + cSpace + IntToStr( Ancestor.TID ) + cCur;
      Genus := MakeHyperlinks( Genus, lt_French, Refer, IsNo );
      if ( Gender = ge_masculine ) then
      begin
        Genus := 'un' + cSpace + Genus;
      end else
      begin
        Genus := 'une' + cSpace + Genus;
      end;

      // Find the differentia
      Diff := 'qui' + cSpace + Self.FDefin[ Indx ].Def;
      Differentia := MakeHyperlinks( Diff, lt_French, Refer, Isno );
      // Make the definition
      TaxDef := Basis + cSpace + Genus + cSpace + Differentia;
    end;
  end;
  Result := TaxDef;
end; // _____________________________________________________MakeTaxFRDefinition

function           TDefinition.MakeTaxESDefinition(
  Indx:            Integer;
  Refer:           Boolean;
  IsNo:            Boolean )
  :                String;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MakeTaxESDefinition
  * Prepare a taxonomic definition with genus and differentia in Spanish *
  Description:
  This method prepares a taxonomic definition from its genus and the given
  differentia, as a full Spanish text ready to display. Resolution of
  references in hyperlinks to other units or entities is performed.</P>
  In case of a non existing entity or an entity without a specified taxonomic
  ancestor, the result is the empty string.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
var
  NbPos:           Integer;
  ActualGen:       Boolean;
  Basis:           String;
  First:           String;
  TaxDef:          String;
  Genus:           String;
  Diff:            String;
  Undef:           String;
  ArtForm:         String;
  Differentia:     String;
  Actual:          TEntity;
  Ancestor:        TEntity;
  Gender:          TGender;
  MyPos:           Array[ 0 .. 2 ] of Integer;
  MyTerm:          tESTerm;
begin
  // Define the entity
  Actual := TAH.GetUnitGenerator( Self.FDefin[ Indx ].UID );
  TaxDef := cEmpty;
  if ( Actual <> nil ) then
  begin

    // Search for genus name, the direct ancestor in taxonomy
    Ancestor := TAH.GetEntityByTID( Actual.TaxAnc );
    Genus := cEmpty;
    Undef := cEmpty;
    if ( Ancestor <> nil ) then
    begin

      // Search if the defined entity is generic
      NbPos := 0;
      ActualGen := False;
      TAH.GetPositionsByGen( Actual.TID, NbPos, MyPos );
      if ( Actual.TaxAnc > 0 ) then
        ActualGen := ( Length( Actual.TaxCh ) > 0 ) or ( NbPos > 0 );
      ActualGen := ActualGen or Actual.Generic;

      // Find the basis
      First := Actual.GetLibelle( lb_Base, lt_Spanish );
      MyTerm := tESTerm.Create( First );
      Gender := MyTerm.GenderES;
      Basis := BTAG + First + BETAG;
      if ( ActualGen ) then
      begin
        ArtForm := 'Uno' + cSpace;
        if ( Gender = ge_feminine ) then
          ArtForm := 'Una' + cSpace;
      end else
      begin
        if CharInSet( First[ 1 ], [ 'a', 'e', 'i', 'o', 'u' ] ) then
        begin
          ArtForm := 'L''';
        end else
        begin
          if ( Gender = ge_masculine ) then
          begin
            ArtForm := 'Le' + cSpace
          end else
          begin
            ArtForm := 'La' + cSpace;
          end;
        end;
      end;
      Basis := ArtForm + Basis + cSpace + 'es';

      // Find the genus
      Genus := Ancestor.GetLibelle( lb_Base, lt_Spanish );
      MyTerm := tESTerm.Create( Genus );
      Gender := MyTerm.GenderES;
      Genus := cCul + Genus + cComma + cSpace + IntToStr( Ancestor.TID ) + cCur;
      Genus := MakeHyperlinks( Genus, lt_Spanish, Refer, IsNo );
      if ( Gender = ge_masculine ) then
      begin
        Genus := 'uno' + cSpace + Genus;
      end else
      begin
        Genus := 'una' + cSpace + Genus;
      end;

      // Find the differentia
      Diff := 'que' + cSpace + Self.FDefin[ Indx ].Def;
      Differentia := MakeHyperlinks( Diff, lt_Spanish, Refer, IsNo );

      // Make the definition
      TaxDef := Basis + cSpace + Genus + cSpace + Differentia;
    end;
  end;
  Result := TaxDef;
end; // _____________________________________________________MakeTaxESDefinition

function           TDefinition.MakeTaxRUDefinition(
  Indx:            Integer;
  Refer:           Boolean;
  IsNo:            Boolean )
  :                String;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MakeTaxRUDefinition
  * Prepare a taxonomic definition with genus and differentia in Russian *
  Description:
  This method prepares a taxonomic definition from its genus and the given
  differentia, as a full Russian text ready to display. Resolution of
  references in hyperlinks to other units or entities is performed.</P>
  In case of a non existing entity or an entity without a specified taxonomic
  ancestor, the result is the empty string.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
var
  NbPos:           Integer;
  Ident:           Integer;
  IsRule:          Boolean;
  ActualGen:       Boolean;
  Basis:           String;
  First:           String;
  TaxDef:          String;
  Genus:           String;
  Diff:            String;
  Undef:           String;
  ArtForm:         String;
  Differentia:     String;
  Actual:          TEntity;
  Ancestor:        TEntity;
  Gender:          TGender;
  MyPos:           Array[ 0 .. 2 ] of Integer;
  MyTerm:          TRUTerm;
begin
  // Define the entity
  Actual := TAH.GetUnitGenerator( Self.FDefin[ Indx ].UID );
  TaxDef := cEmpty;
  if ( Actual <> nil ) then
  begin

    // Search for genus name, the direct ancestor in taxonomy
    Ancestor := TAH.GetEntityByTID( Actual.TaxAnc );
    Genus := cEmpty;
    Undef := cEmpty;
    if ( Ancestor <> nil ) then
    begin

      // Search if the defined entity is generic
      NbPos := 0;
      ActualGen := False;
      TAH.GetPositionsByGen( Actual.TID, NbPos, MyPos );
      if ( Actual.TaxAnc > 0 ) then
        ActualGen := ( Length( Actual.TaxCh ) > 0 ) or ( NbPos > 0 );
      ActualGen := ActualGen or Actual.Generic;

      // Find the basis
      First := Actual.GetLibelle( lb_Base, lt_Russian );
      MyTerm := TRUTerm.Create( First );
      Gender := MyTerm.GenderRU( IsRule, Ident );
      Basis := BTAG + First + BETAG + cSpace + '- это';

      // Find the genus
      Genus := Ancestor.GetLibelle( lb_Base, lt_Russian );
      MyTerm := TRUTerm.Create( Genus );
      Gender := MyTerm.GenderRU( IsRule, Ident );
      Genus := cCul + Genus + cComma + cSpace + IntToStr( Ancestor.TID ) + cCur;
      Genus := MakeHyperlinks( Genus, lt_Russian, Refer, IsNo );

      // Find the differentia
      Diff := 'который' + cSpace + Self.FDefin[ Indx ].Def;
      Differentia := MakeHyperlinks( Diff, lt_Russian, Refer, IsNo );

      // Make the definition
      TaxDef := Basis + cSpace + Genus + cSpace + Differentia;
    end;
  end;
  Result := TaxDef;
end; // _____________________________________________________MakeTaxRUDefinition

function           TDefinition.MakeAutoLateralDef(
  Position:        Integer;
  Side:            TLink )
  :                String;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MakeAutoLateralDef
  * Prepare an autogenerated definition for members of a pair *
  Description:
  This method prepares a taxonomic definition for the lateral members of a pair
  from its genus and the given differentia, as a full English text ready
  to display.</P>
  In case of a non existing entity or an entity without a specified taxonomic
  ancestor, the result is the empty string.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
var
  Indx:            Integer;
  Indy:            Integer;
  DefLg:           TLanguage;
begin
  // Define the entity
  if ( ( Position >= 0 ) and ( Position < Length( Self.FSelPos ) ) ) then
    Indx := Self.FSelPos[ Position ]
  else
    Exit;

  // Search for the language of the definition
  DefLg := lt_None;
  for Indy := 1 to Self.NbSet do
  begin
    if ( ( Indx >= Self.FStart[ Indy ] ) and
         ( Indx <= Self.FStop[ Indy ] ) ) then
      DefLg := Self.FLang[ Indy ];
  end;

  // Dispatch to the language specific methods
  if ( DefLg = lt_English ) then
     Result := Self.MakeAutoLateralENDef( Indx, Side )
  else
  if ( DefLg = lt_French ) then
     Result := Self.MakeAutoLateralFRDef( Indx, Side )
  else
  if ( DefLg = lt_Spanish ) then
     Result := Self.MakeAutoLateralESDef( Indx, Side )
  else
  if ( DefLg = lt_Russian ) then
     Result := Self.MakeAutoLateralENDef( Indx, Side );
end; // ______________________________________________________MakeAutoLateralDef

function           TDefinition.MakeAutoLateralENDef(
  Indx:            Integer;
  Side:            TLink )
  :                String;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MakeAutoLateralENDef
  * Prepare an autogenerated definition for members of a pair *
  Description:
  This method prepares a taxonomic definition from its genus and the given
  differentia, as a full English text ready to display.</P>
  In case of a non existing entity or an entity without a specified taxonomic
  ancestor, the result is the empty string.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
var
  Posit:           Integer;
  ChildTID:        Integer;
  TaxDef:          String;
  Genus:           String;
  Article:         String;
  MySide:          String;
  Children:        String;
  Actual:          TEntity;
  Ancestor:        TEntity;
  Child:           TEntity;
begin
  // Define the entity
  Actual := TAH.GetUnitGenerator( Self.FDefin[ Indx ].UID );
  TaxDef := cEmpty;
  if ( Actual <> nil ) then
  begin
    // Search for the lateral child
    Children := Actual.TaxCh;
    ChildTID := 0;
    Child := nil;
    if ( Children <> cEmpty ) then
    begin
      Posit := Pos( cSemi, Children );
      if ( Posit > 0 ) then
      begin
        if ( Side = pw_MemberL ) then
          ChildTID := StrToInt( Copy( Children, 1, Posit - 1 ) )
        else
        if ( Side = pw_MemberR ) then
          ChildTID := StrToInt( Copy( Children, Posit + 1,
                                Length( Children ) ) );
      end;
    end;
    if ( ChildTID > 0 ) then
      Child := TAH.GetEntityByTID( ChildTID );
    if ( Child = nil ) then
      Exit;

    // Search for genus  name, the direct ancestor in taxonomy
    Ancestor := TAH.GetEntityByTID( Actual.TaxAnc );
    Genus := cEmpty;
    Article := cEmpty;
    if ( Ancestor <> nil ) then
    begin
      TaxDef := Child.GetLibelle( lb_Base, lt_English );
      TaxDef := 'The' + cSpace + BTAG + TaxDef + BETAG + cSpace + 'is';
      Genus := Ancestor.GetLibelle( lb_Base, lt_English );
      Genus := cCul + Genus + cComma + cSpace + IntToStr( Ancestor.TID ) + cCur;
      Article := 'a';
      if CharInSet( Genus[ 1 ], [ 'a', 'e', 'i', 'o', 'u' ] ) then
        Article := 'an';
      TaxDef := TaxDef + cSpace + Article + cSpace + Genus;

      // Add the differentia and side marker
      MySide := cEmpty;
      if ( Child.Link = pw_MemberL ) then
        MySide := 'on the left side'
      else
      if ( Child.Link = pw_MemberR ) then
        MySide := 'on the right side';
      TaxDef := TaxDef + cSpace + 'which' + cSpace +
                Copy( Self.FDefin[ Indx ].Def, 1,
                Length( Self.FDefin[ Indx ].Def ) - 1 ) + cSpace +
                MySide + cPeriod;

      // Resolve the hyperlinks
      TaxDef := MakeHyperlinks( TaxDef, lt_English, False );

      // Prepare the mention of the source
      if ( Self.FDefin[ Indx ].Src = 'FMA' ) then
        TaxDef := TaxDef + cSpace + '(Foundational Model of Anatomy)';
    end;
  end;
  Result := TaxDef;
end; // ____________________________________________________MakeAutoLateralENDef

function           TDefinition.MakeAutoLateralFRDef(
  Indx:            Integer;
  Side:            TLink )
  :                String;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MakeAutoLateralFRDef
  * Prepare an autogenerated French definition for members of a pair *
  Description:
  This method prepares a taxonomic definition from its genus and the given
  differentia, as a full French text ready to display.</P>
  In case of a non existing entity or an entity without a specified taxonomic
  ancestor, the result is the empty string.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
var
  Posit:           Integer;
  ChildTID:        Integer;
  Ident:           Integer;
  IsRule:          Boolean;
  TaxDef:          String;
  Genus:           String;
  Undef:           String;
  MySide:          String;
  ArtForm:         String;
  Children:        String;
  Actual:          TEntity;
  Ancestor:        TEntity;
  Child:           TEntity;
  Gender:          tGender;
  MyTerm:          TFRTerm;
begin
  // Define the entity
  Actual := TAH.GetUnitGenerator( Self.FDefin[ Indx ].UID );
  TaxDef := cEmpty;
  if ( Actual <> nil ) then
  begin
    // Search for the lateral child
    Children := Actual.TaxCh;
    ChildTID := 0;
    Child := nil;
    if ( Children <> cEmpty ) then
    begin
      Posit := Pos( cSemi, Children );
      if ( Posit > 0 ) then
      begin
        if ( Side = pw_MemberL ) then
          ChildTID := StrToInt( Copy( Children, 1, Posit - 1 ) )
        else
        if ( Side = pw_MemberR ) then
          ChildTID := StrToInt( Copy( Children, Posit + 1,
                                      Length( Children ) ) );
      end;
    end;
    if ( ChildTID > 0 ) then
      Child := TAH.GetEntityByTID( ChildTID );
    if ( Child = nil ) then
      Exit;

    // Search for genus name, the direct ancestor in taxonomy
    Ancestor := TAH.GetEntityByTID( Actual.TaxAnc );
    Genus := cEmpty;
    Undef := cEmpty;
    if ( Ancestor <> nil ) then
    begin
      TaxDef := Child.GetLibelle( lb_Base, lt_French );
      if ( not CharInSet( TaxDef[ 1 ], [ 'a', 'e', 'i', 'o', 'u', 'h' ] ) ) then
      begin
        MyTerm := TFRTerm.Create( TaxDef );
        Gender := MyTerm.GenderFR( IsRule, Ident );
        if ( Gender = ge_masculine ) then
          ArtForm := 'Le' + cSpace
        else
          ArtForm := 'La' + cSpace;
      end else
      begin
        ArtForm := 'L''';
      end;
      TaxDef := ArtForm + BTAG + TaxDef + BETAG + cSpace + 'est';
      Genus := Ancestor.GetLibelle( lb_Base, lt_French );
      MyTerm := TFRTerm.Create( Genus );
      Gender := MyTerm.GenderFR( IsRule, Ident );
      Genus := cCul + Genus + cComma + cSpace + IntToStr( Ancestor.TID ) + cCur;
      Undef := 'un';
      if ( Gender = ge_feminine ) then
        Undef := 'une';
      TaxDef := TaxDef + cSpace + Undef + cSpace + Genus;

      // Add the differentia and side marker
      MySide := cEmpty;
      if ( Child.Link = pw_MemberL ) then
        MySide := 'du côté gauche'
      else
      if ( Child.Link = pw_MemberR ) then
        MySide := 'du côté droit';
      TaxDef := TaxDef + cSpace + 'qui' + cSpace +
                Copy( Self.FDefin[ Indx ].Def, 1,
                Length( Self.FDefin[ Indx ].Def ) - 1 ) + cSpace +
                MySide + cPeriod;

      // Resolve the hyperlinks
      TaxDef := MakeHyperlinks( TaxDef, lt_French, False );
    end;
  end;
  Result := TaxDef;
end; // ____________________________________________________MakeAutoLateralFRDef

function           TDefinition.MakeAutoLateralESDef(
  Indx:            Integer;
  Side:            TLink )
  :                String;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MakeAutoLateralESDef
  * Prepare an autogenerated Spanish definition for members of a pair *
  Description:
  This method prepares a taxonomic definition from its genus and the given
  differentia, as a full Spanish text ready to display.</P>
  In case of a non existing entity or an entity without a specified taxonomic
  ancestor, the result is the empty string.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
var
  Posit:           Integer;
  ChildTID:        Integer;
  TaxDef:          String;
  Genus:           String;
  Undef:           String;
  MySide:          String;
  ArtForm:         String;
  Children:        String;
  Actual:          TEntity;
  Ancestor:        TEntity;
  Child:           TEntity;
  Gender:          tGender;
  MyTerm:          tESTerm;
begin
  // Define the entity
  Actual := TAH.GetUnitGenerator( Self.FDefin[ Indx ].UID );
  TaxDef := cEmpty;
  if ( Actual <> nil ) then
  begin
    // Search for the lateral child
    Children := Actual.TaxCh;
    ChildTID := 0;
    Child := nil;
    if ( Children <> cEmpty ) then
    begin
      Posit := Pos( cSemi, Children );
      if ( Posit > 0 ) then
      begin
        if ( Side = pw_MemberL ) then
          ChildTID := StrToInt( Copy( Children, 1, Posit - 1 ) )
        else
        if ( Side = pw_MemberR ) then
          ChildTID := StrToInt( Copy( Children, Posit + 1,
                                      Length( Children ) ) );
      end;
    end;
    if ( ChildTID > 0 ) then
      Child := TAH.GetEntityByTID( ChildTID );
    if ( Child = nil ) then
      Exit;

    // Search for genus name, the direct ancestor in taxonomy
    Ancestor := TAH.GetEntityByTID( Actual.TaxAnc );
    Genus := cEmpty;
    Undef := cEmpty;
    if ( Ancestor <> nil ) then
    begin
      TaxDef := Child.GetLibelle( lb_Base, lt_Spanish );
      MyTerm := tESTerm.Create( TaxDef );
      Gender := MyTerm.GenderES;
      if ( Gender = ge_masculine ) then
        ArtForm := 'El' + cSpace
      else
        ArtForm := 'La' + cSpace;
      TaxDef := ArtForm + BTAG + TaxDef + BETAG + cSpace + 'es';
      Genus := Ancestor.GetLibelle( lb_Base, lt_Spanish );
      MyTerm := tESTerm.Create( Genus );
      Gender := MyTerm.GenderES;
      Genus := cCul + Genus + cComma + cSpace + IntToStr( Ancestor.TID ) + cCur;
      Undef := 'uno';
      if ( Gender = ge_feminine ) then
        Undef := 'una';
      TaxDef := TaxDef + cSpace + Undef + cSpace + Genus;

      // Add the differentia and side marker
      MySide := cEmpty;
      if ( Child.Link = pw_MemberL ) then
        MySide := 'en el lado izquierdo'
      else
      if ( Child.Link = pw_MemberR ) then
        MySide := 'en el lado derecho';
      TaxDef := TaxDef + cSpace + 'que' + cSpace +
                Copy( Self.FDefin[ Indx ].Def, 1,
                Length( Self.FDefin[ Indx ].Def ) - 1 ) + cSpace +
                MySide + cPeriod;

      // Resolve the hyperlinks
      TaxDef := MakeHyperlinks( TaxDef, lt_Spanish, False );
    end;
  end;
  Result := TaxDef;
end; // ____________________________________________________MakeAutoLateralESDef

function           TDefinition.MakeAutoLateralRUDef(
  Indx:            Integer;
  Side:            TLink )
  :                String;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MakeAutoLateralRUDef
  * Prepare an autogenerated Russian definition for members of a pair *
  Description:
  This method prepares a taxonomic definition from its genus and the given
  differentia, as a full Russian text ready to display.</P>
  In case of a non existing entity or an entity without a specified taxonomic
  ancestor, the result is the empty string.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
var
  Posit:           Integer;
  ChildTID:        Integer;
  Ident:           Integer;
  IsRule:          Boolean;
  TaxDef:          String;
  Genus:           String;
  MySide:          String;
  Children:        String;
  Actual:          TEntity;
  Ancestor:        TEntity;
  Child:           TEntity;
  Gender:          tGender;
  MyTerm:          TRUTerm;
begin
  // Define the entity
  Actual := TAH.GetUnitGenerator( Self.FDefin[ Indx ].UID );
  TaxDef := cEmpty;
  if ( Actual <> nil ) then
  begin
    // Search for the lateral child
    Children := Actual.TaxCh;
    ChildTID := 0;
    Child := nil;
    if ( Children <> cEmpty ) then
    begin
      Posit := Pos( cSemi, Children );
      if ( Posit > 0 ) then
      begin
        if ( Side = pw_MemberL ) then
          ChildTID := StrToInt( Copy( Children, 1, Posit - 1 ) )
        else
        if ( Side = pw_MemberR ) then
          ChildTID := StrToInt( Copy( Children, Posit + 1,
                                      Length( Children ) ) );
      end;
    end;
    if ( ChildTID > 0 ) then
      Child := TAH.GetEntityByTID( ChildTID );
    if ( Child = nil ) then
      Exit;

    // Search for genus name, the direct ancestor in taxonomy
    Ancestor := TAH.GetEntityByTID( Actual.TaxAnc );
    Genus := cEmpty;
    if ( Ancestor <> nil ) then
    begin
      TaxDef := Child.GetLibelle( lb_Base, lt_Russian );
      MyTerm := TRUTerm.Create( TaxDef );
      Gender := MyTerm.GenderRU( IsRule, Ident );
      TaxDef := BTAG + TaxDef + BETAG + cSpace + '- это';
      Genus := Ancestor.GetLibelle( lb_Base, lt_Russian );
      MyTerm := TRUTerm.Create( Genus );
      Gender := MyTerm.GenderRU( IsRule, Ident );
      Genus := cCul + Genus + cComma + cSpace + IntToStr( Ancestor.TID ) + cCur;
      TaxDef := TaxDef + cSpace + Genus;

      // Add the differentia and side marker
      MySide := cEmpty;
      if ( Child.Link = pw_MemberL ) then
        MySide := 'с левой стороны'
      else
      if ( Child.Link = pw_MemberR ) then
        MySide := 'с правой стороны';
      TaxDef := TaxDef + cSpace + Copy( Self.FDefin[ Indx ].Def, 1,
                Length( Self.FDefin[ Indx ].Def ) - 1 ) + cSpace +
                MySide + cPeriod;

      // Resolve the hyperlinks
      TaxDef := MakeHyperlinks( TaxDef, lt_Russian, False );
    end;
  end;
  Result := TaxDef;
end; // ____________________________________________________MakeAutoLateralRUDef

function           TDefinition.MakeAutoPairDef(
  Position:        Integer )
  :                String;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MakeAutoPairDef
  * Prepare an autogenerated definition for symmetrical pairs *
  Description:
  This method prepares a taxonomic definition for a pair from the genus of
  the generator and the computation of a differentia, as a full English text
  ready to display.</P>
  In case of a non existing generator or a generator without a specified
  taxonomic definition, the result is the empty string.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
var
  Indx:            Integer;
  Indy:            Integer;
  DefLg:           TLanguage;
begin
  // Define the entity
  if ( ( Position >= 0 ) and ( Position < Length( Self.FSelPos ) ) ) then
    Indx := Self.FSelPos[ Position ]
  else
    Exit;

  // Search for the language of the definition
  DefLg := lt_None;
  for Indy := 1 to Self.NbSet do
  begin
    if ( ( Indx >= Self.FStart[ Indy ] ) and
         ( Indx <= Self.FStop[ Indy ] ) ) then
      DefLg := Self.FLang[ Indy ];
  end;

  // Dispatch to the language specific methods
  if ( DefLg = lt_English ) then
     Result := Self.MakeAutoPairENDef( Indx )
  else
  if ( DefLg = lt_French ) then
     Result := Self.MakeAutoPairFRDef( Indx )
  else
  if ( DefLg = lt_Spanish ) then
     Result := Self.MakeAutoPairESDef( Indx )
  else
  if ( DefLg = lt_Russian ) then
     Result := Self.MakeAutoPairRUDef( Indx );
end; // _________________________________________________________MakeAutoPairDef

function           tDefinition.MakeAutoPairENDef(
  Indx:            Integer )
  :                String;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MakeAutoPairENDef
  * Prepare an autogenerated English definition for symmetrical pairs *
  Description:
  This method prepares a taxonomic definition from the genus of the generator
  and the computation of a differentia, as a full English text ready
  to display.</P>
  In case of a non existing generator or a generator without a specified
  taxonomic definition, the result is the empty string.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
var
  TaxDef:          String;
  Genus:           String;
  Undef:           String;
  Differentia:     String;
  Actual:          tEntity;
  Ancestor:        tEntity;
  MyTerm:          tTerm;
begin

  // Define the entity
  Actual := TAH.GetUnitGenerator( Self.FDefin[ Indx ].UID );
  if ( Actual <> nil ) then
  begin

    // Search for genus name, the direct ancestor in taxonomy
    Ancestor := TAH.GetEntityByTID( Actual.TaxAnc );
    if ( Ancestor <> nil ) then
    begin

      // Build the initial part of definition
      Actual.LgCurrent := lt_English;
      Actual.Query := tSearch.Create( st_bas );
      Actual.SearchTerm;
      if ( Actual.CurrSingle.Effective = st_irr ) then
      begin
        Actual.Query := tSearch.Create( st_for );
        Actual.SearchTerm;
      end;
      MyTerm := tENTerm.Create( Actual.CurrSingle.Mandat );
      TaxDef := MyTerm.Plural;
      TaxDef := 'The pair of' + cSpace + BTAG + TaxDef + BETAG + cSpace + 'is';

      // Build the genus of definition
      Ancestor.LgCurrent := lt_English;
      Ancestor.Query := tSearch.Create( st_bas );
      Ancestor.SearchTerm;
      MyTerm := tENTerm.Create( Ancestor.CurrSingle.Mandat );
      Genus := MyTerm.Plural;
      Undef := 'a';
      if CharInSet( Genus[ 1 ], [ 'a', 'e', 'i', 'o', 'u' ] ) then
        Undef := 'an';
      Genus := cCul + Genus + cComma + cSpace + IntToStr( Ancestor.TID ) + cCur;
      Genus := MakeHyperlinks( Genus, lt_English, False );
      TaxDef := TaxDef + cSpace + Undef + cSpace + 'pair of' + cSpace + Genus;

      // Prepare hyperlinks to other entities in the differentia
      Differentia := MakeHyperlinks( Self.FDefin[ Indx ].Def, lt_English,
                                     True, False );

      // Add the differentia and side marker
      TaxDef := TaxDef + cSpace + 'of which each member' + cSpace + Differentia;

      // Prepare the mention of the source
      if ( Self.FDefin[ Indx ].Src = 'FMA' ) then
        TaxDef := TaxDef + cSpace + '(Foundational Model of Anatomy)';
    end;
  end;
  Result := TaxDef;
end; // _______________________________________________________MakeAutoPairENDef

function           tDefinition.MakeAutoPairFRDef(
  Indx:            Integer )
  :                String;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MakeAutoPairFRDef
  * Prepare an autogenerated French definition for symmetrical pairs *
  Description:
  This method prepares a taxonomic definition from the genus of the generator
  and the computation of a differentia, as a full French text ready
  to display.</P>
  In case of a non existing generator or a generator without a specified
  taxonomic definition, the result is the empty string.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
var
  TaxDef:          String;
  Genus:           String;
  Undef:           String;
  Differentia:     String;
  Init:            String;
  Actual:          TEntity;
  Ancestor:        TEntity;
  MyTerm:          TTerm;
begin
  // Define the entity
  Actual := TAH.GetUnitGenerator( Self.FDefin[ Indx ].UID );
  TaxDef := cEmpty;
  if ( Actual <> nil ) then
  begin

    // Search for genus name, the direct ancestor in taxonomy
    Ancestor := TAH.GetEntityByTID( Actual.TaxAnc );
    Genus := cEmpty;
    Undef := cEmpty;
    if ( Ancestor <> nil ) then
    begin
      TaxDef := Actual.GetLibelle( lb_Base, lt_French );
      Init := 'La paire de' + cSpace;
      if CharInSet( TaxDef[ 1 ], [ 'a', 'e', 'i', 'o', 'u', 'h' ] ) then
        Init := 'La paire d''';
      TaxDef := Init + BTAG + TaxDef + BETAG + cSpace + 'est';
      Genus := Ancestor.GetLibelle( lb_Base, lt_French );
      Init := 'une paire de' + cSpace;
      if CharInSet( Genus[ 1 ], [ 'a', 'e', 'i', 'o', 'u', 'h' ] ) then
        Init := 'une paire d''';
      MyTerm := TFRTerm.Create( Genus );
      Genus := MyTerm.Plural;
      Genus := cCul + Genus + cComma + cSpace + IntToStr( Ancestor.TID ) + cCur;
      Genus := MakeHyperlinks( Genus, lt_French, False );
      TaxDef := TaxDef + cSpace + Init + Genus;

      // Prepare hyperlinks to other entities in the differentia
      Differentia := MakeHyperlinks( Self.FDefin[ Indx ].Def, lt_French,
                                     False );

      // Add the differentia and side marker
      TaxDef := TaxDef + cSpace + 'dont chaque membre' + cSpace + Differentia;
    end;
  end;
  Result := TaxDef;
end; // _______________________________________________________MakeAutoPairFRDef

function           TDefinition.MakeAutoPairESDef(
  Indx:            Integer )
  :                String;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MakeAutoPairESDef
  * Prepare an autogenerated Spanish definition for symmetrical pairs *
  Description:
  This method prepares a taxonomic definition from the genus of the generator
  and the computation of a differentia, as a full Spanish text ready
  to display.</P>
  In case of a non existing generator or a generator without a specified
  taxonomic definition, the result is the empty string.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
var
  TaxDef:          String;
  Genus:           String;
  Undef:           String;
  Differentia:     String;
  Init:            String;
  Actual:          TEntity;
  Ancestor:        TEntity;
  MyTerm:          TTerm;
begin
  // Define the entity
  Actual := TAH.GetUnitGenerator( Self.FDefin[ Indx ].UID );
  TaxDef := cEmpty;
  if ( Actual <> nil ) then
  begin

    // Search for genus name, the direct ancestor in taxonomy
    Ancestor := TAH.GetEntityByTID( Actual.TaxAnc );
    Undef := cEmpty;
    if ( Ancestor <> nil ) then
    begin
      TaxDef := Actual.GetLibelle( lb_Base, lt_Spanish );
      MyTerm := tESTerm.Create( TaxDef );
      TaxDef := MyTerm.Plural;
      Init := 'El par de' + cSpace;
      TaxDef := Init + BTAG + TaxDef + BETAG + cSpace + 'es';
      Genus := Ancestor.GetLibelle( lb_Base, lt_Spanish );
      Init := 'un par de' + cSpace;
      MyTerm := tESTerm.Create( Genus );
      Genus := MyTerm.Plural;
      Genus := cCul + Genus + cComma + cSpace + IntToStr( Ancestor.TID ) + cCur;
      Genus := MakeHyperlinks( Genus, lt_Spanish, False );
      TaxDef := TaxDef + cSpace + Init + Genus;

      // Prepare hyperlinks to other entities in the differentia
      Differentia := MakeHyperlinks( Self.FDefin[ Indx ].Def, lt_Spanish,
                                     False );

      // Add the differentia and side marker
      TaxDef := TaxDef + cSpace + 'cada miembro de la cual' + cSpace +
                Differentia;
    end;
  end;
  Result := TaxDef;
end; // _______________________________________________________MakeAutoPairESDef

function           TDefinition.MakeAutoPairRUDef(
  Indx:            Integer )
  :                String;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MakeAutoPairRUDef
  * Prepare an autogenerated Russian definition for symmetrical pairs *
  Description:
  This method prepares a taxonomic definition from the genus of the generator
  and the computation of a differentia, as a full Russian text ready
  to display. The definition is derived from the source definition of the pair
  generic entity.</P>
  In case of a non existing generator or a generator without a specified
  taxonomic definition, the result is the empty string.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
var
  TaxDef:          String;
  Genus:           String;
  Undef:           String;
  Differentia:     String;
  Init:            String;
  Actual:          TEntity;
  Ancestor:        TEntity;
  MyTerm:          TTerm;
begin
  // Define the entity
  Actual := TAH.GetUnitGenerator( Self.FDefin[ Indx ].UID );
  TaxDef := cEmpty;
  if ( Actual <> nil ) then
  begin

    // Search for genus name, the direct ancestor in taxonomy
    Ancestor := TAH.GetEntityByTID( Actual.TaxAnc );
    Undef := cEmpty;
    if ( Ancestor <> nil ) then
    begin
      TaxDef := Actual.GetLibelle( lb_Base, lt_Russian );
      MyTerm := TRUTerm.Create( TaxDef );
      TaxDef := MyTerm.GenPlural;
      Init := 'пара' + cSpace;
      TaxDef := Init + BTAG + TaxDef + BETAG + cSpace + '- это';
      Genus := Ancestor.GetLibelle( lb_Base, lt_Russian );
      Init := 'пара' + cSpace;
      MyTerm := TRUTerm.Create( Genus );
      Genus := MyTerm.GenPlural;
      Genus := cCul + Genus + cComma + cSpace + IntToStr( Ancestor.TID ) + cCur;
      Genus := MakeHyperlinks( Genus, lt_Russian, False );
      TaxDef := TaxDef + cSpace + Init + Genus;

      // Prepare hyperlinks to other entities in the differentia
      Differentia := MakeHyperlinks( Self.FDefin[ Indx ].Def, lt_Russian,
                                     False );

      // Add the differentia and side marker
      TaxDef := TaxDef + cSpace + 'каждый член которой' + cSpace +
                Differentia;
    end;
  end;
  Result := TaxDef;
end; // _______________________________________________________MakeAutoPairRUDef

function           TDefinition.MakeAutoSetDef(
  Position:        Integer )
  :                String;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MakeAutoSetDef
  * Prepare an autogenerated taxonomic definition for sets *
  Description:
  This method prepares a taxonomic definition for a set from its genus and
  the given differentia, as a full text ready to display.</P>
  In case of a non existing entity or an entity without a specified taxonomic
  ancestor, the result is the empty string.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
var
  Indx:            Integer;
  Indy:            Integer;
  DefLg:           TLanguage;
begin
  // Define the entity
  if ( ( Position >= 0 ) and ( Position < Length( Self.FSelPos ) ) ) then
    Indx := Self.FSelPos[ Position ]
  else
    Exit;

  // Search for the language of the definition
  DefLg := lt_None;
  for Indy := 1 to Self.NbSet do
  begin
    if ( ( Indx >= Self.FStart[ Indy ] ) and
         ( Indx <= Self.FStop[ Indy ] ) ) then
      DefLg := Self.FLang[ Indy ];
  end;

  // Dispatch to the language specific methods
  if ( DefLg = lt_English ) then
     Result := Self.MakeAutoSetENDef( Indx )
  else
  if ( DefLg = lt_French ) then
     Result := Self.MakeAutoSetFRDef( Indx );
end; // __________________________________________________________MakeAutoSetDef

function           TDefinition.MakeAutoSetENDef(
  Indx:            Integer )
  :                String;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MakeAutoSetENDef
  * Prepare an English autogenerated definition for sets *
  Description:
  This method prepares a taxonomic definition from its genus and the given
  differentia, as a full English text ready to display.</P>
  In case of a non existing entity or an entity without a specified taxonomic
  ancestor, the result is the empty string.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
var
  TaxDef:          String;
  Genus:           String;
  Undef:           String;
  Differentia:     String;
  Actual:          TEntity;
  Ancestor:        TEntity;
  MyTerm:          TTerm;
begin
  // Define the entity
  Actual := TAH.GetUnitGenerator( Self.FDefin[ Indx ].UID );
  TaxDef := cEmpty;
  if ( Actual <> nil ) then
  begin

    // Search for genus name, the direct ancestor in taxonomy
    Ancestor := TAH.GetEntityByTID( Actual.TaxAnc );
    Genus := cEmpty;
    Undef := cEmpty;
    if ( Ancestor <> nil ) then
    begin
      TaxDef := Actual.GetLibelle( lb_Base, lt_English );
      TaxDef := 'The' + cSpace + BTAG + TaxDef + BETAG + cSpace + 'is';
      Genus := Ancestor.GetLibelle( lb_Base, lt_English );
      Genus := cCul + Genus + cComma + cSpace + IntToStr( Ancestor.TID ) + cCur;
      Undef := 'a';
      if CharInSet( Genus[ 1 ], [ 'a', 'e', 'i', 'o', 'u' ] ) then
        Undef := 'an';
      MyTerm := TENTerm.Create( Genus );
      TaxDef := TaxDef + cSpace + Undef + cSpace +
                'set of' + cSpace + MyTerm.Plural;

      // Prepare hyperlinks to other entities in the differentia
      Differentia := Self.FDefin[ Indx ].Def;

      // Add the differentia and side marker
      TaxDef := TaxDef + cSpace + 'of which each member' + cSpace + Differentia;
      TaxDef := MakeHyperlinks( TaxDef, lt_English, false );

      // Prepare the mention of the source
      if ( Self.FDefin[ Indx ].Src = 'FMA' ) then
        TaxDef := TaxDef + cSpace + '(Foundational Model of Anatomy)';
    end;
  end;
  Result := TaxDef;
end; // ________________________________________________________MakeAutoSetENDef

function           TDefinition.MakeAutoSetFRDef(
  Indx:            Integer )
  :                String;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MakeAutoSetFRDef
  * Prepare an autogenerated French definition for sets *
  Description:
  This method prepares a taxonomic definition from its genus and the given
  differentia, as a full French text ready to display.</P>
  In case of a non existing entity or an entity without a specified taxonomic
  ancestor, the result is the empty string.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
var
  TaxDef:          String;
  Genus:           String;
  Undef:           String;
  Differentia:     String;
  Actual:          TEntity;
  Ancestor:        TEntity;
  MyTerm:          TTerm;
begin
  // Define the entity
  Actual := TAH.GetUnitGenerator( Self.FDefin[ Indx ].UID );
  TaxDef := cEmpty;
  if ( Actual <> nil ) then
  begin

    // Search for genus name, the direct ancestor in taxonomy
    Ancestor := TAH.GetEntityByTID( Actual.TaxAnc );
    Genus := cEmpty;
    Undef := cEmpty;
    if ( Ancestor <> nil ) then
    begin
      TaxDef := Actual.GetLibelle( lb_Base, lt_French );
      TaxDef := 'Le' + cSpace + TaxDef + cSpace + 'est';
      Genus := Ancestor.GetLibelle( lb_Base, lt_French );
      Genus := cCul + Genus + cComma + cSpace + IntToStr( Ancestor.TID ) + cCur;
      MyTerm := TFRTerm.Create( Genus );
      Undef := 'un';
      TaxDef := TaxDef + cSpace + Undef + cSpace +
                'ensemble de' + cSpace + MyTerm.Plural;

      // Add the differentia and side marker
      Differentia := MakeHyperlinks( Self.FDefin[ Indx ].Def, lt_French,
                                     False );
      TaxDef := TaxDef + cSpace + 'dont chaque membre' + cSpace + Differentia;

      // Prepare the mention of the source
      if ( Self.FDefin[ Indx ].Src = 'FMA' ) then
        TaxDef := TaxDef + cSpace + '(Foundational Model of Anatomy)';
    end;
  end;
  Result := TaxDef;
end; // ________________________________________________________MakeAutoSetFRDef

function           TDefinition.MakeAutoPstDef(
  Position:        Integer )
  :                String;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MakeAutoPstDef
  * Prepare an autogenerated taxonomic definition for a pair of sets *
  Description:
  This method prepares a taxonomic definition for a paired set from its genus
  and the given differentia, as a full text ready to display.</P>
  In case of a non existing entity or an entity without a specified taxonomic
  ancestor, the result is the empty string.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
var
  Indx:            Integer;
  Indy:            Integer;
  DefLg:           TLanguage;
begin
  // Define the entity
  if ( ( Position >= 0 ) and ( Position < Length( Self.FSelPos ) ) ) then
    Indx := Self.FSelPos[ Position ]
  else
    Exit;

  // Search for the language of the definition
  DefLg := lt_None;
  for Indy := 1 to Self.NbSet do
  begin
    if ( ( Indx >= Self.FStart[ Indy ] ) and
         ( Indx <= Self.FStop[ Indy ] ) ) then
      DefLg := Self.FLang[ Indy ];
  end;

  // Dispatch to the language specific methods
  if ( DefLg = lt_English ) then
     Result := Self.MakeAutoPstENDef( Indx )
  else
  if ( DefLg = lt_French ) then
     Result := Self.MakeAutoPstFRDef( Indx )
  else
  if ( DefLg = lt_Spanish ) then
     Result := Self.MakeAutoPstESDef( Indx )
  else
  if ( DefLg = lt_Russian ) then
     Result := Self.MakeAutoPstRUDef( Indx );
end; // __________________________________________________________MakeAutoPstDef

function           TDefinition.MakeAutoPstENDef(
  Indx:            Integer )
  :                String;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MakeAutoPstENDef
  * Prepare an English autogenerated definition for a pair of sets *
  Description:
  This method prepares a taxonomic definition from its genus and the given
  differentia, as a full English text ready to display.</P>
  In case of a non existing entity or an entity without a specified taxonomic
  ancestor, the result is the empty string.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
var
  Lgt:             Integer;
  TaxDef:          String;
  Genus:           String;
  Undef:           String;
  Actual:          TEntity;
  Ancestor:        TEntity;
  MyTerm:          TTerm;
begin
  // Define the entity
  Actual := TAH.GetUnitGenerator( Self.FDefin[ Indx ].UID );
  TaxDef := cEmpty;
  if ( Actual <> nil ) then
  begin

    // Search for genus name, the direct ancestor in taxonomy
    Ancestor := TAH.GetEntityByTID( Actual.TaxAnc );
    Genus := cEmpty;
    Undef := cEmpty;
    if ( Ancestor <> nil ) then
    begin
      TaxDef := Actual.GetLibelle( lb_Base, lt_English );
      TaxDef := 'The' + cSpace + BTAG + TaxDef + BETAG + cSpace + 'is';
      Genus := Ancestor.GetLibelle( lb_Base, lt_English );
      Genus := cCul + Genus + cComma + cSpace + IntToStr( Ancestor.TID ) + cCur;
      Genus := MakeHyperlinks( Genus, lt_English, False );
      Undef := 'a';
      if CharInSet( Genus[ 1 ], [ 'a', 'e', 'i', 'o', 'u' ] ) then
        Undef := 'an';
      MyTerm := TENTerm.Create( Genus );
      TaxDef := TaxDef + cSpace + Undef + cSpace + 'pair of sets of' +
                cSpace + MyTerm.Plural;

      // Add the differentia and side marker
      Lgt := Length( Self.FDefin[ Indx ].Def );
      TaxDef := TaxDef + cSpace + 'of which each lateral member is' +
                cSpace + 'a set of entities which' +
                cSpace + MakeHyperlinks( Self.FDefin[ Indx ].Def, lt_English,
                                         False );

      // Prepare the mention of the source
      if ( Self.FDefin[ Indx ].Src = 'FMA' ) then
        TaxDef := TaxDef + cSpace + '(Foundational Model of Anatomy)';
    end;
  end;
  Result := TaxDef;
end; // ________________________________________________________MakeAutoPstENDef

function           TDefinition.MakeAutoPstFRDef(
  Indx:            Integer )
  :                String;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MakeAutoPstFRDef
  * Prepare an autogenerated French definition for a pair of sets *
  Description:
  This method prepares a taxonomic definition from its genus and the given
  differentia, as a full French text ready to display.</P>
  In case of a non existing entity or an entity without a specified taxonomic
  ancestor, the result is the empty string.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
var
  TaxDef:          String;
  Genus:           String;
  Undef:           String;
  Actual:          TEntity;
  Ancestor:        TEntity;
begin
  // Define the entity
  Actual := TAH.GetUnitGenerator( Self.FDefin[ Indx ].UID );
  TaxDef := cEmpty;
  if ( Actual <> nil ) then
  begin

    // Search for genus name, the direct ancestor in taxonomy
    Ancestor := TAH.GetEntityByTID( Actual.TaxAnc );
    Genus := cEmpty;
    Undef := cEmpty;
    if ( Ancestor <> nil ) then
    begin
      TaxDef := Actual.GetLibelle( lb_Base, lt_French );
      TaxDef := 'Le' + cSpace + TaxDef + cSpace + 'est';
      Genus := Ancestor.GetLibelle( lb_Base, lt_French );
      Undef := 'un';
      if CharInSet( Genus[ 1 ], [ 'a', 'e', 'i', 'o', 'u' ] ) then
        Undef := 'an';
      TaxDef := TaxDef + cSpace + Undef + cSpace + 'ensemble de ' + Genus + 's';

      // Add the differentia and side marker
      TaxDef := TaxDef + cSpace + 'dont chaque membre' +
                cSpace + Self.FDefin[ Indx ].Def;

      // Prepare the mention of the source
      if ( Self.FDefin[ Indx ].Src = 'FMA' ) then
        TaxDef := TaxDef + cSpace + '(Foundational Model of Anatomy)';
    end;
  end;
  Result := TaxDef;
end; // ________________________________________________________MakeAutoPstFRDef

function           TDefinition.MakeAutoPstESDef(
  Indx:            Integer )
  :                String;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MakeAutoPstESDef
  * Prepare an autogenerated Spanish definition for a pair of sets *
  Description:
  This method prepares a taxonomic definition from its genus and the given
  differentia, as a full Spanish text ready to display.</P>
  In case of a non existing entity or an entity without a specified taxonomic
  ancestor, the result is the empty string.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
var
  TaxDef:          String;
  Genus:           String;
  Undef:           String;
  Differentia:     String;
  Actual:          TEntity;
  Ancestor:        TEntity;
  MyTerm:          TTerm;
begin
  // Define the entity
  Actual := TAH.GetUnitGenerator( Self.FDefin[ Indx ].UID );
  TaxDef := cEmpty;
  if ( Actual <> nil ) then
  begin

    // Search for genus name, the direct ancestor in taxonomy
    Ancestor := TAH.GetEntityByTID( Actual.TaxAnc );
    Genus := cEmpty;
    Undef := cEmpty;
    if ( Ancestor <> nil ) then
    begin
      TaxDef := Actual.GetLibelle( lb_Base, lt_Spanish );
      MyTerm := tESTerm.Create( TaxDef );
      TaxDef := MyTerm.Plural;
      TaxDef := 'La' + cSpace + 'par de juntos de ' + TaxDef + cSpace + 'es';
      Genus := Ancestor.GetLibelle( lb_Base, lt_Spanish );
      MyTerm := tESTerm.Create( Genus );
      Genus := MyTerm.Plural;
      Undef := 'una';
      TaxDef := TaxDef + cSpace + Undef + cSpace + 'par de juntos de ' + Genus;
      Differentia := MakeHyperlinks( Self.FDefin[ Indx ].Def, lt_Spanish,
                                     False );

      // Add the differentia and side marker
      TaxDef := TaxDef + cSpace + 'cada miembro de la cual' +
                cSpace + Differentia;

      // Prepare the mention of the source
      if ( Self.FDefin[ Indx ].Src = 'FMA' ) then
        TaxDef := TaxDef + cSpace + '(Foundational Model of Anatomy)';
    end;
  end;
  Result := TaxDef;
end; // ________________________________________________________MakeAutoPstESDef

function           tDefinition.MakeAutoPstRUDef(
  Indx:            Integer )
  :                String;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MakeAutoPstRUDef
  * Prepare an autogenerated Russian definition for a pair of sets *
  Description:
  This method prepares a taxonomic definition from its genus and the given
  differentia, as a full Russian text ready to display.</P>
  In case of a non existing entity or an entity without a specified taxonomic
  ancestor, the result is the empty string.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
var
  TaxDef:          String;
  Genus:           String;
  Undef:           String;
  Differentia:     String;
  Actual:          tEntity;
  Ancestor:        tEntity;
  MyTerm:          tTerm;
begin
  // Define the entity
  Actual := TAH.GetUnitGenerator( Self.FDefin[ Indx ].UID );
  TaxDef := cEmpty;
  if ( Actual <> nil ) then
  begin

    // Search for genus name, the direct ancestor in taxonomy
    Ancestor := TAH.GetEntityByTID( Actual.TaxAnc );
    Genus := cEmpty;
    Undef := cEmpty;
    if ( Ancestor <> nil ) then
    begin
      TaxDef := Actual.GetLibelle( lb_Base, lt_Russian );
      MyTerm := tRUTerm.Create( TaxDef );
      TaxDef := MyTerm.GenPlural;
      TaxDef := 'пара вместов' + cSpace + TaxDef + cSpace + 'это';
      Genus := Ancestor.GetLibelle( lb_Base, lt_Russian );
      MyTerm := tRUTerm.Create( Genus );
      Genus := MyTerm.GenPlural;
      Undef := 'uno';
      TaxDef := TaxDef + cSpace + Undef + cSpace + 'пара вместов ' + Genus;
      Differentia := MakeHyperlinks( Self.FDefin[ Indx ].Def, lt_Russian,
                                     False );

      // Add the differentia and side marker
      TaxDef := TaxDef + cSpace + 'каждый член которой' +
                cSpace + Differentia;

      // Prepare the mention of the source
      if ( Self.FDefin[ Indx ].Src = 'FMA' ) then
        TaxDef := TaxDef + cSpace + '(Foundational Model of Anatomy)';
    end;
  end;
  Result := TaxDef;
end; // ________________________________________________________MakeAutoPstRUDef

function           MakeHyperlinks(
  Mydef:           String;
  Lang:            tLanguage;
  Refer:           Boolean;
  IsNo:            Boolean )
  :                String;
{<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MakeHyperlinks
  * Resolve hyperlinks in the specified language *
  Description:
  This method scans the raw text of a definition as issued from the database
  in HTML format. It searches for any number of pairs of curled brackets, each
  of them specifying an hyperlink to be created.</P>
  The interior of each bracket pair is made of two strings separated by a
  comma. The first string is any text representing an entity, that is to be
  left unchanged in the textual stream. The second string represents an
  entity identifier, specifying an Entity page where the hyperlink has to
  move. The hyperlink is positionned on the first string.</P>
  This procedure is valid for all languages. However, the hyperlink has to
  adress a Unit page with the same main and display languages.</P>
  The parameter Refer, if true (false by default), commands the addition of a
  pair of square brackets immediately after the hyperlink, containing the
  Latin short official term of the specified entity.</P>
  The parameter IsNo, if true (false by default), asks for the suppression of
  all reference in the text.</P>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
var
  Posit:           Integer;
  Start:           Integer;
  Stop:            Integer;
  Lgt:             Integer;
  MyTID:           Integer;
  DefText:         String;
  Bracket:         String;
  Before:          String;
  After:           String;
  Atext:           String;
  AnID:            String;
  ARef:            String;
  LAText:          String;
  LangDir:         String;
  MyEntity:        tEntity;
begin
  // Initial stuff
  DefText := Mydef;
  Result := MyDef;
  Lgt := Length( MyDef );

  // Define the language path
  LangDir := cLgShort[ TAH.MainLang ];
  if ( TAH.MainLang = lt_Latin ) then
    LangDir := LangDir + cLgShort[ TAH.SubstLang ];
  LangDir := LangDir + cSlash;

  // Loop on several possible texts in curled brackets
  Start := Pos( cCul, DefText );
  while ( Start > 0 ) do
  begin

    // Extract the next text in curled brackets
    Before := Copy( DefText, 1, Start - 1 );
    DefText := Copy( DefText, Start + 1, Lgt );
    Stop := Pos( cCur, DefText );
    if ( Stop = 0 ) then
      Exit;
    Bracket := Copy( DefText, 1, Stop - 1 );
    After := Copy( DefText, Stop + 1, Lgt );

    // Transform the text in curled brackets
    Posit := Pos( cComma, Bracket );
    if ( Posit = 0 ) then
      Exit;
    AText := Copy( Bracket, 1, Posit - 1 );
    AnID := Copy( Bracket, Posit + 2, Length( Bracket ) );
    AnID := Trim( AnID );
    if ( ( not Refer ) and ( not IsNo ) ) then
      Bracket := AOTAG + cHrefEmpty + cRetroDir + LangDir +
                 cTAH + AnID + cSpace + cLgShort[ TAH.DisLanguage ] +
                 cPeriod + HtmlExt + cDQuote + cAnr + AText + AETAG
    else
      Bracket := AText;

    // Add the Latin text and reference in square brackets
    ARef := cEmpty;
    if ( Refer and ( AnID <> cEmpty ) ) then
    begin
      MyTID := StrToInt( AnID );
      MyEntity := TAH.GetEntityByPos( MyTID );
      LAText := cEmpty;
      if ( MyEntity <> nil ) then
      begin
        LAText := MyEntity.GetLibelle( lb_Base, lt_Latin );
        LAText := AOTAG + cHrefEmpty + cRetroDir + LangDir +
                  cTAH + AnID + cSpace + cLgShort[ TAH.DisLanguage ] +
                  cPeriod + HtmlExt + cDQuote + cAnr + LAText + AETAG;
      end;
      ARef := cSpace + cSql + LAText + cSqr;
    end;

    // Rebuild the plain text of definition
    DefText := Before + Bracket + ARef + After;
    Result := DefText;
    Start := Pos( cCul, DefText );
  end; // while on all pairs of curled brackets
end; // __________________________________________________________MakeHyperlinks

end.
